<script setup>
import '@harbour-enterprises/common/styles/common-styles.css';
//prettier-ignore
import {
  getCurrentInstance,
  ref,
  onMounted,
  onBeforeUnmount,
  nextTick,
  computed,
  reactive,
  watch,
} from 'vue';
import { storeToRefs } from 'pinia';

import PdfViewer from './components/PdfViewer/PdfViewer.vue';
import CommentsLayer from './components/CommentsLayer/CommentsLayer.vue';
import CommentDialog from '@/components/CommentsLayer/CommentDialog.vue';
import FloatingComments from '@/components/CommentsLayer/FloatingComments.vue';
import HrbrFieldsLayer from '@/components/HrbrFieldsLayer/HrbrFieldsLayer.vue';
import useSelection from '@/helpers/use-selection';

import { useSuperdocStore } from '@/stores/superdoc-store';
import { useCommentsStore } from '@/stores/comments-store';

import { DOCX, PDF, HTML } from '@harbour-enterprises/common';
import { SuperEditor } from '@harbour-enterprises/super-editor';
import HtmlViewer from './components/HtmlViewer/HtmlViewer.vue';
import useConversation from './components/CommentsLayer/use-conversation';
import useComment from './components/CommentsLayer/use-comment';

// Stores
const superdocStore = useSuperdocStore();
const commentsStore = useCommentsStore();
const emit = defineEmits(['selection-update']);

//prettier-ignore
const {
  documents,
  isReady,
  areDocumentsReady,
  selectionPosition,
  activeSelection,
  activeZoom,
} = storeToRefs(superdocStore);
const { handlePageReady, modules, user, getDocument } = superdocStore;

//prettier-ignore
const {
  getConfig,
  documentsWithConverations,
  pendingComment,
  activeComment,
  skipSelectionUpdate
} = storeToRefs(commentsStore);
const { initialCheck, showAddComment } = commentsStore;
const { proxy } = getCurrentInstance();
commentsStore.proxy = proxy;

// Refs
const layers = ref(null);

// Comments layer
const commentsLayer = ref(null);
const toolsMenuPosition = reactive({ top: null, right: '-25px', zIndex: 10 });

// Hrbr Fields
const hrbrFieldsLayer = ref(null);

const handleDocumentReady = (documentId, container) => {
  const doc = getDocument(documentId);
  doc.isReady = true;
  doc.container = container;
  if (areDocumentsReady.value) {
    isReady.value = true;
    nextTick(() => initialCheck());
  }
  proxy.$superdoc.broadcastPdfDocumentReady();
};

const handleToolClick = (tool) => {
  const toolOptions = {
    comments: showAddComment,
  };

  if (tool in toolOptions) {
    toolOptions[tool](activeSelection.value, selectionPosition.value);
  }

  activeSelection.value = null;
  toolsMenuPosition.top = null;
};

const handleDocumentMouseDown = (e) => {
  if (pendingComment.value) return;
};

const handleHighlightClick = () => (toolsMenuPosition.top = null);
const cancelPendingComment = (e) => {
  if (e.target.classList.contains('n-dropdown-option-body__label')) return;
};

const onCommentsLoaded = ({ comments }) => {
  proxy.$superdoc.log('[superdoc] onCommentsLoaded', comments);
  comments.forEach((c) => {
    const convo = useConversation(c);
    const doc = getDocument(c.documentId);
    doc.conversations.push(convo);
  });
  isReady.value = true;
};

const onEditorBeforeCreate = ({ editor }) => {
  proxy.$superdoc.broadcastEditorBeforeCreate(editor);
};

const onEditorCreate = ({ editor }) => {
  const { documentId } = editor.options;
  const doc = getDocument(documentId);
  doc.setEditor(editor);
  proxy.$superdoc.activeEditor = editor;
  proxy.$superdoc.broadcastEditorCreate(editor);
  proxy.$superdoc.log('[Superdoc] Editor created', proxy.$superdoc.activeEditor);
  proxy.$superdoc.log('[Superdoc] Page styles (pixels)', editor.getPageStyles());
};

const onEditorDestroy = () => {
  proxy.$superdoc.broadcastEditorDestroy();
};

const onEditorFocus = ({ editor }) => {
  proxy.$superdoc.setActiveEditor(editor);
};

const onEditorDocumentLocked = ({ editor, isLocked, lockedBy }) => {
  proxy.$superdoc.lockSuperdoc(isLocked, lockedBy);
};

const onEditorSelectionChange = ({ editor, transaction }) => {
  if (skipSelectionUpdate.value) {
    // When comment is added selection will be equal to comment text
    // Should skip calculations to keep text selection for comments correct
    skipSelectionUpdate.value = false;
    return;
  }
  const { documentId } = editor.options;
  const { $from, $to } = transaction.selection;
  if ($from.pos === $to.pos) {
    updateSelection({ x: null, y: null, x2: null, y2: null, source: 'super-editor' });
  }

  const layerBounds = layers.value.getBoundingClientRect();
  const bounds = getSelectionBoundingBox();
  if (!bounds || !layerBounds) return;

  const selectionBounds = {
    top: (bounds.top - layerBounds.top) / activeZoom.value,
    left: (bounds.left - layerBounds.left) / activeZoom.value,
    right: (bounds.right - layerBounds.left) / activeZoom.value,
    bottom: (bounds.bottom - layerBounds.top) / activeZoom.value,
  };

  const selection = useSelection({
    selectionBounds,
    page: 1,
    documentId,
    source: 'super-editor',
  });

  handleSelectionChange(selection);

  // TODO: Figure out why the selection is being undone here and we need the delay
  setTimeout(() => {
    const { activeThreadId } = transaction.getMeta('commentsPluginState') || {};
    const document = getDocument(documentId);
    const convo = document.conversations.find((c) => c.thread == activeThreadId);
    activeComment.value = convo?.conversationId;
  }, 250);
};

const onEditorCommentsUpdate = ({ editor, transaction }) => {
  const { documentId } = editor.options;
  const { commentPositions = {}, activeThreadId } =
    transaction.getMeta('commentsPluginState') || {};
  if (activeThreadId) onEditorSelectionChange({ editor, transaction });

  if (!Object.keys(commentPositions).length) return;

  const containerBounds = layers.value.getBoundingClientRect();
  const document = getDocument(documentId);

  Object.keys(commentPositions).forEach((threadId) => {
    let convo = document.conversations.find((c) => c.thread == threadId);
    const commentData = commentPositions[threadId];

    if (!convo && commentData.type === 'trackedChange') {
      const selection = useSelection({
        page: 1,
        selectionBounds: commentPositions[threadId],
        documentId,
        source: 'super-editor',
      });

      const trackedChange = {};
      if (commentData.insertion) {
        trackedChange.insertion = commentData.insertion;
      } else if (commentData.deletion) {
        trackedChange.deletion = commentData.deletion;
      }
      const comment = useComment({
        id: threadId,
        trackedChange: commentData,
        user: {
          email: proxy.$superdoc.user.email,
          name: proxy.$superdoc.user.name,
        },
      });

      convo = useConversation({
        thread: threadId,
        isTrackedChange: true,
        documentId,
        comments: [comment],
        creatorEmail: proxy.$superdoc.user.email,
        creatorName: proxy.$superdoc.user.name,
        selection,
      });
      document.conversations.push(convo);
    } else if (commentData.type === 'trackedChange') {
      convo.comments[0].trackedChange = commentData;
    }

    if (convo) {
      const adjustedSelection = {
        top: commentPositions[threadId].top - containerBounds.top,
        left: commentPositions[threadId].left - containerBounds.left,
        right: commentPositions[threadId].right - containerBounds.left,
        bottom: commentPositions[threadId].bottom - containerBounds.top,
      };

      const newSelection = useSelection({
        selectionBounds: adjustedSelection,
        documentId,
        source: 'super-editor',
      });
      convo.selection = newSelection;
    }
  });
};

function getSelectionBoundingBox() {
  const selection = window.getSelection();

  if (selection.rangeCount > 0) {
    const range = selection.getRangeAt(0);
    return range.getBoundingClientRect();
  }

  return null;
}

const onCommentClicked = ({ conversation }) => {
  const { conversationId } = conversation;
  activeComment.value = conversationId;
};

const onEditorCollaborationReady = ({ editor }) => {
  proxy.$superdoc.emit('collaboration-ready', { editor });
};

const onEditorContentError = ({ error, editor }) => {
  proxy.$superdoc.emit('content-error', { error, editor });
};

const updateToolbarState = () => {
  proxy.$superdoc.toolbar.updateToolbarState();
};

const handleEditorClick = ({ editor }) => updateToolbarState();

const handleEditorKeydown = ({ editor }) => updateToolbarState();

const editorOptions = (doc) => {
  const options = {
    pagination: proxy.$superdoc.config.pagination,
    documentId: doc.id,
    user: proxy.$superdoc.user,
    colors: proxy.$superdoc.colors,
    role: proxy.$superdoc.config.role,
    documentMode: proxy.$superdoc.config.documentMode,
    onBeforeCreate: onEditorBeforeCreate,
    onCreate: onEditorCreate,
    onDestroy: onEditorDestroy,
    onFocus: onEditorFocus,
    onDocumentLocked: onEditorDocumentLocked,
    onSelectionUpdate: onEditorSelectionChange,
    onCollaborationReady: onEditorCollaborationReady,
    onContentError: onEditorContentError,
    // onCommentsLoaded,
    // onCommentClicked,
    // onCommentsUpdate: onEditorCommentsUpdate,
    ydoc: doc.ydoc,
    collaborationProvider: doc.provider || null,
    isNewFile: doc.isNewFile || false,
    handleImageUpload: proxy.$superdoc.config.handleImageUpload,
  };

  return options;
};

const isCommentsEnabled = computed(() => 'comments' in modules);
const showCommentsSidebar = computed(() => {
  return (
    pendingComment.value ||
    (documentsWithConverations.value.length > 0 && layers.value && isReady.value && isCommentsEnabled.value)
  );
});

const showToolsFloatingMenu = computed(() => {
  if (!isCommentsEnabled.value) return false;
  return toolsMenuPosition.top && !getConfig.value?.readOnly;
});
const showActiveSelection = computed(() => {
  if (!isCommentsEnabled.value) return false;
  !getConfig?.readOnly && selectionPosition.value;
});

watch(showCommentsSidebar, (value) => {
  proxy.$superdoc.broadcastSidebarToggle(value);
});

onMounted(() => {
  if (isCommentsEnabled.value && !modules.comments.readOnly) {
    document.addEventListener('mousedown', handleDocumentMouseDown);
  }
});

onBeforeUnmount(() => {
  document.removeEventListener('mousedown', handleDocumentMouseDown);
});

const selectionLayer = ref(null);
const isDragging = ref(false);

const getSelectionPosition = computed(() => {
  if (!selectionPosition.value || selectionPosition.value.source === 'super-editor') {
    return { x: null, y: null };
  }

  const top = selectionPosition.value.top;
  const left = selectionPosition.value.left;
  const right = selectionPosition.value.right;
  const bottom = selectionPosition.value.bottom;
  const style = {
    zIndex: 500,
    borderRadius: '4px',
    top: top + 'px',
    left: left + 'px',
    height: Math.abs(top - bottom) + 'px',
    width: Math.abs(left - right) + 'px',
  };
  return style;
});

const handleSelectionChange = (selection) => {
  if (!selection.selectionBounds || !isCommentsEnabled.value) return;

  const isMobileView = window.matchMedia('(max-width: 768px)').matches;

  updateSelection({
    startX: selection.selectionBounds.left,
    startY: selection.selectionBounds.top,
    x: selection.selectionBounds.right,
    y: selection.selectionBounds.bottom,
    source: selection.source,
  });

  if (!selectionPosition.value) return;
  const selectionIsWideEnough =
    Math.abs(selectionPosition.value.left - selectionPosition.value.right) > 5;
  const selectionIsTallEnough =
    Math.abs(selectionPosition.value.top - selectionPosition.value.bottom) > 5;
  if (!selectionIsWideEnough || !selectionIsTallEnough) {
    selectionLayer.value.style.pointerEvents = 'none';
    resetSelection();
    return;
  }

  activeSelection.value = selection;

  // Place the tools menu at the level of the selection
  let top = selection.selectionBounds.top;
  if (selection.bottom - selection.selectionBounds.top < 0) {
    top = selection.selectionBounds.botton;
  }

  toolsMenuPosition.top = top - 20 + 'px';
  toolsMenuPosition.right = isMobileView ? '0' : '-25px';
};

const resetSelection = () => {
  selectionPosition.value = null;
};

const updateSelection = ({ startX, startY, x, y, source }) => {
  const hasStartCoords = startX || startY;
  const hasEndCoords = x || y;

  if (!hasStartCoords && !hasEndCoords) {
    return (selectionPosition.value = null);
  }

  // Initialize the selection position
  if (!selectionPosition.value) {
    if (startY <= 0 || startX <= 0) return;
    selectionPosition.value = {
      top: startY,
      left: startX,
      right: startX,
      bottom: startY,
      startX,
      startY,
      source,
    };
  }

  if (startX) selectionPosition.value.startX = startX;
  if (startY) selectionPosition.value.startY = startY;

  // Reverse the selection if the user drags up or left
  const selectionTop = selectionPosition.value.startY;
  if (y < selectionTop) {
    selectionPosition.value.top = y;
  } else {
    selectionPosition.value.bottom = y;
  }

  const selectionLeft = selectionPosition.value.startX;
  if (x < selectionLeft) {
    selectionPosition.value.left = x;
  } else {
    selectionPosition.value.right = x;
  }
};

const handleSelectionStart = (e) => {
  resetSelection();
  selectionLayer.value.style.pointerEvents = 'auto';

  nextTick(() => {
    isDragging.value = true;
    const y = e.offsetY / activeZoom.value;
    const x = e.offsetX / activeZoom.value;
    updateSelection({ startX: x, startY: y });
    selectionLayer.value.addEventListener('mousemove', handleDragMove);
  });
};

const handleDragMove = (e) => {
  if (!isDragging.value) return;
  const y = e.offsetY / activeZoom.value;
  const x = e.offsetX / activeZoom.value;
  updateSelection({ x, y });
};

const handleDragEnd = (e) => {
  if (!isDragging.value) return;
  selectionLayer.value.removeEventListener('mousemove', handleDragMove);

  if (!selectionPosition.value) return;
  const selection = useSelection({
    selectionBounds: {
      top: selectionPosition.value.top,
      left: selectionPosition.value.left,
      right: selectionPosition.value.right,
      bottom: selectionPosition.value.bottom,
    },
    documentId: documents.value[0].id,
  });
  handleSelectionChange(selection);
  selectionLayer.value.style.pointerEvents = 'none';
};

const handlePdfClick = (e) => {
  if (!isCommentsEnabled.value) return;
  resetSelection();
  isDragging.value = true;
  handleSelectionStart(e);
};
</script>

<template>
  <div class="superdoc">
    <div class="layers" ref="layers">
      <!-- Floating tools menu (shows up when user has text selection)-->
      <div v-if="showToolsFloatingMenu" class="tools" :style="toolsMenuPosition">
        <div class="tools-item" data-id="is-tool" @click.stop.prevent="handleToolClick('comments')">
          <i class="fas fa-comment fa-tool-icon"></i>
        </div>
      </div>

      <div class="document">
        <div
          v-if="isCommentsEnabled"
          class="selection-layer"
          @mousedown="handleSelectionStart"
          @mouseup="handleDragEnd"
          ref="selectionLayer"
        >
          <div
            :style="getSelectionPosition"
            class="sd-highlight sd-initial-highlight temp-selection"
            v-if="selectionPosition"
          ></div>
        </div>

        <!-- Fields layer -->
        <HrbrFieldsLayer
          v-if="'hrbr-fields' in modules && layers"
          :fields="modules['hrbr-fields']"
          class="comments-layer"
          style="z-index: 5"
          ref="hrbrFieldsLayer"
        />

        <!-- On-document comments layer -->
        <CommentsLayer
          class="comments-layer"
          v-if="showCommentsSidebar"
          style="z-index: 3"
          ref="commentsLayer"
          :parent="layers"
          :user="user"
          @highlight-click="handleHighlightClick"
        />

        <div class="sub-document" v-for="doc in documents" :key="doc.id">
          <!-- PDF renderer -->

          <PdfViewer
            v-if="doc.type === PDF"
            :document-data="doc"
            @selection-change="handleSelectionChange"
            @ready="handleDocumentReady"
            @page-loaded="handlePageReady"
            @bypass-selection="handlePdfClick"
          />

          <SuperEditor
            v-if="doc.type === DOCX"
            @editor-click="handleEditorClick"
            @editor-keydown="handleEditorKeydown"
            :file-source="doc.data"
            :state="doc.state"
            :document-id="doc.id"
            :options="editorOptions(doc)"
          />

          <!-- omitting field props -->
          <HtmlViewer
            v-if="doc.type === HTML"
            @ready="(id) => handleDocumentReady(id, null)"
            @selection-change="handleSelectionChange"
            :file-source="doc.data"
            :document-id="doc.id"
          />
        </div>
      </div>
    </div>

    <div class="right-sidebar" v-if="showCommentsSidebar">
      <CommentDialog
        v-if="pendingComment"
        :data="pendingComment"
        :current-document="getDocument(pendingComment.documentId)"
        :user="user"
        :parent="layers"
        v-click-outside="cancelPendingComment"
      />

      <FloatingComments
        v-if="isReady"
        v-for="doc in documentsWithConverations"
        :parent="layers"
        :current-document="doc"
      />
    </div>
  </div>
</template>

<style scoped>
.selection-layer {
  position: absolute;
  min-height: 100%;
  min-width: 100%;
  z-index: 10;
  pointer-events: none;
}
.temp-selection {
  position: absolute;
}
/* Right sidebar drawer */
.right-sidebar {
  width: 320px;
  padding: 0 10px;
  min-height: 100%;
  position: relative;
  z-index: 100;
}
.fa-tool-icon {
  cursor: pointer;
}

/* General Styles */
.box-sizing,
.layers {
  box-sizing: border-box;
}
.cursor-pointer,
.tools .tool-icon,
.toolbar-item {
  cursor: pointer;
}
.flex {
  display: flex;
}
.flex-column {
  flex-direction: column;
}
.flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Layer Styles */
.comments-layer {
  position: absolute;
  top: 0;
  height: 100%;
  position: relative;
}

/* Document Styles */
.docx {
  border: 1px solid #dfdfdf;
  pointer-events: auto;
}
.sub-document {
  position: relative;
}

/* Toolbar Styles */
.toolbar {
  height: 25px;
  background-color: #fff;
  margin-bottom: 5px;
}
.toolbar-item {
  width: 20px;
  height: 20px;
  border-radius: 8px;
  border: 1px solid #dbdbdb;
  padding: 3px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: all 250ms ease;
}
.toolbar-item:hover {
  background-color: #dbdbdb;
}

/* Tools Styles */
.tools {
  position: absolute;
  z-index: 100;
  display: flex;
  gap: 6px;
}
.tools .tool-icon {
  font-size: 20px;
  border-radius: 12px;
  border: none;
  outline: none;
  background-color: #dbdbdb;
}
.tools-item {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 50px;
  height: 50px;
  background-color: rgba(219, 219, 219, 0.6);
  border-radius: 12px;
  cursor: pointer;
}

.tools__icon :deep(svg) {
  max-width: 100%;
  max-height: 100%;
  display: block;
  fill: currentColor;
}

.layers {
  position: relative;
  height: 100%;
}

.document {
  position: relative;
}

/* Mobile Styles */
@media (max-width: 768px) {
  .sub-document {
    max-width: 100%;
  }
  .right-sidebar {
    padding: 10px;
    width: 55px;
    position: relative;
  }

  .superdoc .layers {
    margin: 0;
    border: 0 !important;
    box-shadow: none;
  }
}
</style>
